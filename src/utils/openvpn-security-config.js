const path = require('path');
const fs = require('fs-extra');
const crypto = require('crypto');
const { spawn } = require('cross-spawn');

/**
 * OpenVPN Security Configuration Manager
 * Implements hardened OpenVPN server configuration according to security best practices
 */
class OpenVPNSecurityConfig {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    this.platform = process.platform;
  }

  /**
   * Generate hardened OpenVPN server configuration
   * Implements requirements 3.1-3.5 from the security hardening spec
   */
  generateHardenedConfig(certDir, options = {}) {
    const {
      port = 1194,
      protocol = 'udp',
      subnet = '10.8.0.0',
      netmask = '255.255.255.0',
      dnsServers = ['1.1.1.1', '1.0.0.1'], // Cloudflare DNS for security
      logDir = '/var/log/openvpn'
    } = options;

    // Normalize paths for Windows
    const normalizePath = (filePath) => {
      return this.platform === 'win32' ? filePath.replace(/\\/g, '\\\\') : filePath;
    };

    const config = `# OpenVPN Hardened Server Configuration
# Generated by VPN Security Hardening System
# Implements security requirements 3.1-3.5

# Basic Server Settings
port ${port}
proto ${protocol}
dev tun
topology subnet

# Certificate and Key Files
ca ${normalizePath(path.join(certDir, 'ca.crt'))}
cert ${normalizePath(path.join(certDir, 'server.crt'))}
key ${normalizePath(path.join(certDir, 'server.key'))}
dh ${normalizePath(path.join(certDir, 'dh.pem'))}

# TLS Authentication (Requirement 3.2)
tls-crypt ${normalizePath(path.join(certDir, 'ta.key'))}
tls-version-min 1.2
tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384

# Strong Encryption (Requirement 3.1)
cipher AES-256-GCM
auth SHA256
ncp-ciphers AES-256-GCM:AES-128-GCM:AES-256-CBC

# Perfect Forward Secrecy (Requirement 3.2)
ecdh-curve prime256v1

# Certificate Verification (Requirement 3.3)
remote-cert-tls client
verify-client-cert require
crl-verify ${normalizePath(path.join(certDir, 'crl.pem'))}

# Network Configuration
server ${subnet} ${netmask}
push "redirect-gateway def1 bypass-dhcp"

# DNS Configuration and Leak Protection (Requirement 3.4)
${dnsServers.map(dns => `push "dhcp-option DNS ${dns}"`).join('\n')}
push "block-outside-dns"

# Connection Security and Timeouts (Requirement 3.5)
keepalive 10 60
ping-timer-rem
inactive 3600
ping-exit 180

# Security Hardening
${this.platform !== 'win32' ? 'user nobody\ngroup nogroup' : '# Windows does not support user/group options'}
persist-key
persist-tun
chroot ${this.platform !== 'win32' ? '/var/empty' : '# Windows does not support chroot'}

# Disable compression for security (prevents VORACLE attacks)
compress lz4-v2
push "compress lz4-v2"

# Client connection limits
max-clients 100
duplicate-cn

# Logging and Monitoring (Enhanced)
verb 3
mute 20
status ${normalizePath(path.join(logDir, 'openvpn-status.log'))} 10
log-append ${normalizePath(path.join(logDir, 'openvpn.log'))}

# Additional Security Options
script-security 2
# Note: up/down scripts can be configured if needed
# up ${normalizePath(path.join(certDir, 'scripts', 'up.sh'))}
# down ${normalizePath(path.join(certDir, 'scripts', 'down.sh'))}

# Prevent DNS leaks and enforce secure DNS
push "dhcp-option DOMAIN-ROUTE ."
push "register-dns"

# Client-specific configurations directory
client-config-dir ${normalizePath(path.join(certDir, 'ccd'))}

# Management interface (localhost only for security)
management 127.0.0.1 7505

# Explicit exit notify
explicit-exit-notify 1
`;

    return config;
  }

  /**
   * Generate TLS authentication key for additional security layer
   */
  async generateTLSAuthKey(certDir) {
    const taKeyPath = path.join(certDir, 'ta.key');
    
    try {
      // Check if ta.key already exists
      if (await fs.pathExists(taKeyPath)) {
        this.logger.info('TLS auth key already exists, skipping generation');
        return taKeyPath;
      }

      this.logger.info('Generating TLS authentication key...');
      
      // Generate TLS auth key using OpenVPN
      const result = await this.runCommand('openvpn', ['--genkey', '--secret', taKeyPath]);
      
      if (result.success) {
        this.logger.info(`TLS auth key generated at: ${taKeyPath}`);
        
        // Set secure permissions
        if (this.platform !== 'win32') {
          await fs.chmod(taKeyPath, 0o600);
        }
        
        return taKeyPath;
      } else {
        throw new Error(`Failed to generate TLS auth key: ${result.error}`);
      }
    } catch (error) {
      this.logger.error('Error generating TLS auth key:', error);
      throw error;
    }
  }

  /**
   * Generate strong Diffie-Hellman parameters for perfect forward secrecy
   */
  async generateDHParams(certDir, keySize = 2048) {
    const dhPath = path.join(certDir, 'dh.pem');
    
    try {
      // Check if DH params already exist
      if (await fs.pathExists(dhPath)) {
        this.logger.info('DH parameters already exist, skipping generation');
        return dhPath;
      }

      this.logger.info(`Generating ${keySize}-bit DH parameters (this may take several minutes)...`);
      
      // Generate DH params using OpenSSL
      const result = await this.runCommand('openssl', [
        'dhparam',
        '-out', dhPath,
        keySize.toString()
      ]);
      
      if (result.success) {
        this.logger.info(`DH parameters generated at: ${dhPath}`);
        
        // Set secure permissions
        if (this.platform !== 'win32') {
          await fs.chmod(dhPath, 0o600);
        }
        
        return dhPath;
      } else {
        throw new Error(`Failed to generate DH parameters: ${result.error}`);
      }
    } catch (error) {
      this.logger.error('Error generating DH parameters:', error);
      throw error;
    }
  }

  /**
   * Create client-specific configuration directory
   */
  async createClientConfigDir(certDir) {
    const ccdDir = path.join(certDir, 'ccd');
    
    try {
      await fs.ensureDir(ccdDir);
      
      if (this.platform !== 'win32') {
        await fs.chmod(ccdDir, 0o700);
      }
      
      this.logger.info(`Client config directory created at: ${ccdDir}`);
      return ccdDir;
    } catch (error) {
      this.logger.error('Error creating client config directory:', error);
      throw error;
    }
  }

  /**
   * Create firewall scripts for enhanced security
   */
  async createFirewallScripts(certDir) {
    const scriptsDir = path.join(certDir, 'scripts');
    await fs.ensureDir(scriptsDir);
    
    const upScript = path.join(scriptsDir, 'up.sh');
    const downScript = path.join(scriptsDir, 'down.sh');
    
    if (this.platform === 'win32') {
      this.logger.info('Firewall scripts not supported on Windows');
      return;
    }

    try {
      // Create up script
      const upScriptContent = `#!/bin/bash
# OpenVPN up script - Configure firewall rules
iptables -I FORWARD -i $dev -j ACCEPT
iptables -I FORWARD -o $dev -j ACCEPT
iptables -I INPUT -i $dev -j ACCEPT
iptables -t nat -I POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE

# Log connection
logger "OpenVPN: Client connected from $trusted_ip"
`;

      // Create down script
      const downScriptContent = `#!/bin/bash
# OpenVPN down script - Clean up firewall rules
iptables -D FORWARD -i $dev -j ACCEPT 2>/dev/null
iptables -D FORWARD -o $dev -j ACCEPT 2>/dev/null
iptables -D INPUT -i $dev -j ACCEPT 2>/dev/null
iptables -t nat -D POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE 2>/dev/null

# Log disconnection
logger "OpenVPN: Client disconnected from $trusted_ip"
`;

      await fs.writeFile(upScript, upScriptContent);
      await fs.writeFile(downScript, downScriptContent);
      
      // Make scripts executable
      await fs.chmod(upScript, 0o755);
      await fs.chmod(downScript, 0o755);
      
      this.logger.info('Firewall scripts created');
    } catch (error) {
      this.logger.error('Error creating firewall scripts:', error);
      throw error;
    }
  }

  /**
   * Validate hardened configuration
   */
  async validateConfiguration(configPath) {
    try {
      this.logger.info('Validating OpenVPN configuration...');
      
      const result = await this.runCommand('openvpn', [
        '--config', configPath,
        '--test-crypto'
      ]);
      
      if (result.success) {
        this.logger.info('OpenVPN configuration validation passed');
        return true;
      } else {
        this.logger.error('OpenVPN configuration validation failed:', result.error);
        return false;
      }
    } catch (error) {
      this.logger.error('Error validating configuration:', error);
      return false;
    }
  }

  /**
   * Run command with promise wrapper
   */
  runCommand(command, args) {
    return new Promise((resolve) => {
      const process = spawn(command, args);
      let stdout = '';
      let stderr = '';

      process.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          stdout,
          stderr,
          error: code !== 0 ? stderr : null
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          error: error.message
        });
      });
    });
  }
}

module.exports = OpenVPNSecurityConfig;