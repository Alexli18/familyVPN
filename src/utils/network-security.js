const fs = require('fs-extra');
const path = require('path');
const { spawn } = require('cross-spawn');

/**
 * Network Security Manager
 * Implements basic network security and firewall rules for VPN traffic protection
 * Requirements: 6.1, 6.2, 6.3
 */
class NetworkSecurityManager {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    this.platform = process.platform;
    
    // Use certificate directory for scripts if /etc/openvpn is not accessible
    this.scriptsDir = this.getScriptsDirectory();
    this.firewallRulesFile = path.join(this.scriptsDir, 'firewall-rules.sh');
    this.clientAccessFile = path.join(config.certificates.dir, 'client-access.conf');
  }

  /**
   * Get appropriate scripts directory based on permissions
   */
  getScriptsDirectory() {
    const systemDir = '/etc/openvpn';
    const userDir = path.join(this.config.certificates.dir, 'scripts');
    
    try {
      // Try to access system directory
      if (this.platform !== 'win32') {
        require('fs').accessSync(systemDir, require('fs').constants.W_OK);
        return systemDir;
      }
    } catch (error) {
      // Fall back to user directory
      this.logger.info(`Using user scripts directory: ${userDir} (system directory not accessible)`);
    }
    
    return userDir;
  }

  /**
   * Initialize network security - main entry point
   * Requirement 6.2: Automatically configure firewall rules when VPN server starts
   */
  async initializeNetworkSecurity() {
    try {
      this.logger.info('Initializing network security...');
      
      // Create firewall rules
      await this.createFirewallRules();
      
      // Setup client access control
      await this.setupClientAccessControl();
      
      // Configure DNS leak protection
      await this.configureDNSLeakProtection();
      
      // Apply firewall rules
      await this.applyFirewallRules();
      
      this.logger.info('Network security initialized successfully');
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize network security:', error);
      throw error;
    }
  }

  /**
   * Create comprehensive firewall rules for VPN traffic protection
   * Requirement 6.1: Filter client traffic based on defined policies
   */
  async createFirewallRules() {
    if (this.platform === 'win32') {
      this.logger.info('Firewall rules not supported on Windows platform');
      return;
    }

    const firewallScript = `#!/bin/bash
# VPN Security Hardening - Firewall Rules
# Generated by Network Security Manager
# Requirements: 6.1, 6.2

set -e

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

echo -e "\${GREEN}[INFO]\${NC} Applying VPN firewall rules..."

# Configuration
VPN_INTERFACE="tun0"
VPN_SUBNET="${this.config.vpn.subnet}/24"
VPN_PORT="${this.config.vpn.port}"
MGMT_PORT="3000"
EXTERNAL_INTERFACE=\$(ip route | grep default | awk '{print \$5}' | head -n1)

# Function to log firewall actions
log_action() {
    logger "VPN-FIREWALL: \$1"
    echo -e "\${GREEN}[FIREWALL]\${NC} \$1"
}

# Function to check if rule exists
rule_exists() {
    iptables -C \$@ 2>/dev/null
}

# Backup existing rules
echo -e "\${YELLOW}[INFO]\${NC} Backing up existing iptables rules..."
iptables-save > ${this.scriptsDir}/iptables-backup-\$(date +%Y%m%d-%H%M%S).rules

# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf

log_action "Enabling IP forwarding"

# INPUT chain rules
log_action "Configuring INPUT chain rules"

# Allow loopback
if ! rule_exists INPUT -i lo -j ACCEPT; then
    iptables -A INPUT -i lo -j ACCEPT
    log_action "Added loopback rule"
fi

# Allow established and related connections
if ! rule_exists INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT; then
    iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    log_action "Added established connections rule"
fi

# Allow OpenVPN port with rate limiting
if ! rule_exists INPUT -p udp --dport \$VPN_PORT -m limit --limit 10/min -j ACCEPT; then
    iptables -A INPUT -p udp --dport \$VPN_PORT -m limit --limit 10/min -j ACCEPT
    log_action "Added OpenVPN port rule with rate limiting"
fi

# Allow management API from private networks only
if ! rule_exists INPUT -p tcp --dport \$MGMT_PORT -s 10.0.0.0/8 -j ACCEPT; then
    iptables -A INPUT -p tcp --dport \$MGMT_PORT -s 10.0.0.0/8 -j ACCEPT
fi
if ! rule_exists INPUT -p tcp --dport \$MGMT_PORT -s 172.16.0.0/12 -j ACCEPT; then
    iptables -A INPUT -p tcp --dport \$MGMT_PORT -s 172.16.0.0/12 -j ACCEPT
fi
if ! rule_exists INPUT -p tcp --dport \$MGMT_PORT -s 192.168.0.0/16 -j ACCEPT; then
    iptables -A INPUT -p tcp --dport \$MGMT_PORT -s 192.168.0.0/16 -j ACCEPT
fi
log_action "Added management API access rules"

# Allow VPN interface traffic
if ! rule_exists INPUT -i \$VPN_INTERFACE -j ACCEPT; then
    iptables -A INPUT -i \$VPN_INTERFACE -j ACCEPT
    log_action "Added VPN interface input rule"
fi

# Drop invalid packets
if ! rule_exists INPUT -m conntrack --ctstate INVALID -j DROP; then
    iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
    log_action "Added invalid packet drop rule"
fi

# FORWARD chain rules
log_action "Configuring FORWARD chain rules"

# Allow VPN client to VPN client communication
if ! rule_exists FORWARD -i \$VPN_INTERFACE -o \$VPN_INTERFACE -j ACCEPT; then
    iptables -A FORWARD -i \$VPN_INTERFACE -o \$VPN_INTERFACE -j ACCEPT
    log_action "Added VPN client-to-client communication rule"
fi

# Allow VPN clients to internet (with restrictions)
if ! rule_exists FORWARD -i \$VPN_INTERFACE -o \$EXTERNAL_INTERFACE -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT; then
    iptables -A FORWARD -i \$VPN_INTERFACE -o \$EXTERNAL_INTERFACE -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
    log_action "Added VPN to internet forwarding rule"
fi

# Allow return traffic from internet to VPN clients
if ! rule_exists FORWARD -i \$EXTERNAL_INTERFACE -o \$VPN_INTERFACE -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT; then
    iptables -A FORWARD -i \$EXTERNAL_INTERFACE -o \$VPN_INTERFACE -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    log_action "Added internet to VPN return traffic rule"
fi

# Block access to local network from VPN clients (security measure)
if ! rule_exists FORWARD -i \$VPN_INTERFACE -d 192.168.0.0/16 -j DROP; then
    iptables -A FORWARD -i \$VPN_INTERFACE -d 192.168.0.0/16 -j DROP
    log_action "Added local network protection rule"
fi

# NAT/MASQUERADE rules
log_action "Configuring NAT rules"

# Masquerade VPN traffic going to internet
if ! iptables -t nat -C POSTROUTING -s \$VPN_SUBNET -o \$EXTERNAL_INTERFACE -j MASQUERADE 2>/dev/null; then
    iptables -t nat -A POSTROUTING -s \$VPN_SUBNET -o \$EXTERNAL_INTERFACE -j MASQUERADE
    log_action "Added NAT masquerade rule"
fi

# Security rules
log_action "Applying additional security rules"

# Rate limit new connections
if ! rule_exists INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j ACCEPT; then
    iptables -A INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j ACCEPT
    log_action "Added connection rate limiting"
fi

# Protect against port scanning
if ! rule_exists INPUT -m recent --name portscan --rcheck --seconds 86400 -j DROP; then
    iptables -A INPUT -m recent --name portscan --rcheck --seconds 86400 -j DROP
    iptables -A INPUT -m recent --name portscan --set -j LOG --log-prefix "Portscan blocked: "
    log_action "Added port scan protection"
fi

# Log dropped packets (sample only to avoid log flooding)
if ! rule_exists INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables denied: "; then
    iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables denied: "
    log_action "Added packet logging rule"
fi

echo -e "\${GREEN}[SUCCESS]\${NC} Firewall rules applied successfully"
log_action "Firewall configuration completed successfully"
`;

    try {
      await fs.ensureDir(path.dirname(this.firewallRulesFile));
      await fs.writeFile(this.firewallRulesFile, firewallScript);
      await fs.chmod(this.firewallRulesFile, 0o755);
      
      this.logger.info(`Firewall rules script created at: ${this.firewallRulesFile}`);
    } catch (error) {
      this.logger.error('Error creating firewall rules script:', error);
      throw error;
    }
  }

  /**
   * Setup client access control using certificate common names
   * Requirement 6.2: Network access based on client certificate attributes
   */
  async setupClientAccessControl() {
    try {
      this.logger.info('Setting up client access control...');
      
      // Create client access configuration
      const clientAccessConfig = `# Client Access Control Configuration
# Generated by Network Security Manager
# Requirement 6.2: Access control based on certificate attributes

# Default policy: Allow all authenticated clients
# Individual client restrictions can be added below

# Example client-specific configurations:
# client-config-dir /etc/openvpn/ccd
# 
# To restrict a specific client, create a file in ccd/ with the client's common name
# and add restrictions like:
# ifconfig-push 10.8.0.100 255.255.255.0
# push "route 192.168.1.0 255.255.255.0"

# Client certificate validation settings
verify-client-cert require
remote-cert-tls client

# Certificate revocation list
crl-verify ${path.join(this.config.certificates.dir, 'crl.pem')}

# Client connection logging
client-connect ${path.join(this.scriptsDir, 'client-connect.sh')}
client-disconnect ${path.join(this.scriptsDir, 'client-disconnect.sh')}

# Maximum clients per certificate
duplicate-cn

# Client timeout settings
inactive 3600
ping-exit 180
`;

      await fs.writeFile(this.clientAccessFile, clientAccessConfig);
      this.logger.info(`Client access control configured at: ${this.clientAccessFile}`);
      
      // Create client connect/disconnect scripts for logging and access control
      await this.createClientScripts();
      
    } catch (error) {
      this.logger.error('Error setting up client access control:', error);
      throw error;
    }
  }

  /**
   * Create client connect/disconnect scripts for enhanced monitoring
   */
  async createClientScripts() {
    if (this.platform === 'win32') {
      this.logger.info('Client scripts not supported on Windows platform');
      return;
    }

    const connectScript = path.join(this.scriptsDir, 'client-connect.sh');
    const disconnectScript = path.join(this.scriptsDir, 'client-disconnect.sh');

    const connectScriptContent = `#!/bin/bash
# Client Connect Script
# Logs client connections and applies access controls

# Environment variables provided by OpenVPN:
# $common_name - Client certificate common name
# $trusted_ip - Client's real IP address
# $ifconfig_pool_remote_ip - VPN IP assigned to client

# Log connection
logger "VPN-ACCESS: Client '$common_name' connected from $trusted_ip (VPN IP: $ifconfig_pool_remote_ip)"

# Security logging
echo "$(date): CONNECT - CN: $common_name, Real IP: $trusted_ip, VPN IP: $ifconfig_pool_remote_ip" >> ${path.join(this.config.certificates.dir, 'client-access.log')}

# Apply client-specific firewall rules based on common name
case "$common_name" in
    "admin_"*)
        # Admin clients get full access
        logger "VPN-ACCESS: Admin access granted to $common_name"
        ;;
    "guest_"*)
        # Guest clients get restricted access
        logger "VPN-ACCESS: Guest access granted to $common_name"
        # Block access to local networks
        iptables -I FORWARD -s $ifconfig_pool_remote_ip -d 192.168.0.0/16 -j DROP
        iptables -I FORWARD -s $ifconfig_pool_remote_ip -d 10.0.0.0/8 -j DROP
        iptables -I FORWARD -s $ifconfig_pool_remote_ip -d 172.16.0.0/12 -j DROP
        ;;
    *)
        # Default access for regular clients
        logger "VPN-ACCESS: Standard access granted to $common_name"
        ;;
esac

# Rate limiting per client
iptables -I FORWARD -s $ifconfig_pool_remote_ip -m limit --limit 100/sec --limit-burst 200 -j ACCEPT
iptables -I FORWARD -s $ifconfig_pool_remote_ip -j DROP

exit 0
`;

    const disconnectScriptContent = `#!/bin/bash
# Client Disconnect Script
# Logs client disconnections and cleans up access controls

# Log disconnection
logger "VPN-ACCESS: Client '$common_name' disconnected from $trusted_ip"

# Security logging
echo "$(date): DISCONNECT - CN: $common_name, Real IP: $trusted_ip, VPN IP: $ifconfig_pool_remote_ip" >> ${path.join(this.config.certificates.dir, 'client-access.log')}

# Clean up client-specific firewall rules
iptables -D FORWARD -s $ifconfig_pool_remote_ip -m limit --limit 100/sec --limit-burst 200 -j ACCEPT 2>/dev/null
iptables -D FORWARD -s $ifconfig_pool_remote_ip -j DROP 2>/dev/null

# Clean up guest restrictions if applicable
case "$common_name" in
    "guest_"*)
        iptables -D FORWARD -s $ifconfig_pool_remote_ip -d 192.168.0.0/16 -j DROP 2>/dev/null
        iptables -D FORWARD -s $ifconfig_pool_remote_ip -d 10.0.0.0/8 -j DROP 2>/dev/null
        iptables -D FORWARD -s $ifconfig_pool_remote_ip -d 172.16.0.0/12 -j DROP 2>/dev/null
        ;;
esac

exit 0
`;

    try {
      await fs.writeFile(connectScript, connectScriptContent);
      await fs.writeFile(disconnectScript, disconnectScriptContent);
      await fs.chmod(connectScript, 0o755);
      await fs.chmod(disconnectScript, 0o755);
      
      // Ensure log directory exists
      await fs.ensureDir(path.dirname(path.join(this.config.certificates.dir, 'client-access.log')));
      
      this.logger.info('Client connect/disconnect scripts created');
    } catch (error) {
      this.logger.error('Error creating client scripts:', error);
      throw error;
    }
  }

  /**
   * Configure DNS settings to prevent leaks
   * Requirement 6.3: DNS leak protection
   */
  async configureDNSLeakProtection() {
    try {
      this.logger.info('Configuring DNS leak protection...');
      
      const dnsConfig = `# DNS Leak Protection Configuration
# Generated by Network Security Manager
# Requirement 6.3: Prevent DNS leaks

# Secure DNS servers (Cloudflare)
push "dhcp-option DNS 1.1.1.1"
push "dhcp-option DNS 1.0.0.1"

# Alternative secure DNS servers (Quad9)
# push "dhcp-option DNS 9.9.9.9"
# push "dhcp-option DNS 149.112.112.112"

# Block outside DNS to prevent leaks
push "block-outside-dns"

# Force all DNS queries through VPN
push "dhcp-option DOMAIN-ROUTE ."
push "register-dns"

# Redirect all traffic through VPN (prevents DNS leaks)
push "redirect-gateway def1 bypass-dhcp"

# Additional DNS security measures
push "dhcp-option DOMAIN local"
push "dhcp-option ADAPTER_DOMAIN_SUFFIX local"

# IPv6 DNS leak protection
push "dhcp-option DNS6 2606:4700:4700::1111"
push "dhcp-option DNS6 2606:4700:4700::1001"
`;

      const dnsConfigFile = path.join(this.config.certificates.dir, 'dns-protection.conf');
      await fs.writeFile(dnsConfigFile, dnsConfig);
      
      this.logger.info(`DNS leak protection configured at: ${dnsConfigFile}`);
      
      // Create DNS monitoring script
      await this.createDNSMonitoringScript();
      
    } catch (error) {
      this.logger.error('Error configuring DNS leak protection:', error);
      throw error;
    }
  }

  /**
   * Create DNS monitoring script to detect potential leaks
   */
  async createDNSMonitoringScript() {
    if (this.platform === 'win32') {
      this.logger.info('DNS monitoring script not supported on Windows platform');
      return;
    }

    const monitorScript = path.join(this.scriptsDir, 'dns-monitor.sh');
    const monitorScriptContent = `#!/bin/bash
# DNS Leak Monitoring Script
# Monitors for potential DNS leaks and logs suspicious activity

# Configuration
LOG_FILE="/var/log/openvpn/dns-monitor.log"
VPN_INTERFACE="tun0"
ALLOWED_DNS_SERVERS="1.1.1.1 1.0.0.1 9.9.9.9 149.112.112.112"

# Function to log DNS events
log_dns_event() {
    echo "$(date): $1" >> $LOG_FILE
    logger "VPN-DNS: $1"
}

# Monitor DNS queries from VPN clients
monitor_dns_queries() {
    # Use tcpdump to monitor DNS traffic on VPN interface
    tcpdump -i $VPN_INTERFACE -n port 53 -l | while read line; do
        # Extract DNS server from query
        dns_server=$(echo "$line" | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' | tail -1)
        
        if [ ! -z "$dns_server" ]; then
            # Check if DNS server is in allowed list
            if ! echo "$ALLOWED_DNS_SERVERS" | grep -q "$dns_server"; then
                log_dns_event "POTENTIAL DNS LEAK: Query to unauthorized DNS server $dns_server"
                
                # Block the unauthorized DNS server
                iptables -I FORWARD -d $dns_server -p udp --dport 53 -j DROP
                iptables -I FORWARD -d $dns_server -p tcp --dport 53 -j DROP
                
                log_dns_event "BLOCKED: Unauthorized DNS server $dns_server"
            fi
        fi
    done
}

# Start monitoring if VPN interface exists
if ip link show $VPN_INTERFACE >/dev/null 2>&1; then
    log_dns_event "Starting DNS leak monitoring on $VPN_INTERFACE"
    monitor_dns_queries &
else
    log_dns_event "VPN interface $VPN_INTERFACE not found, monitoring disabled"
fi
`;

    try {
      await fs.writeFile(monitorScript, monitorScriptContent);
      await fs.chmod(monitorScript, 0o755);
      
      this.logger.info('DNS monitoring script created');
    } catch (error) {
      this.logger.error('Error creating DNS monitoring script:', error);
      throw error;
    }
  }

  /**
   * Apply firewall rules
   */
  async applyFirewallRules() {
    if (this.platform === 'win32') {
      this.logger.info('Firewall rules not supported on Windows platform');
      return;
    }

    if (this.platform === 'darwin') {
      this.logger.info('Firewall rules not supported on macOS platform (use pfctl or built-in firewall)');
      this.logger.info('For production macOS deployment, configure firewall manually or use pfctl');
      return;
    }

    // Only apply Linux-specific firewall rules on Linux
    if (this.platform !== 'linux') {
      this.logger.info(`Firewall rules not supported on platform: ${this.platform}`);
      return;
    }

    try {
      this.logger.info('Applying firewall rules...');
      
      // Check if required commands exist before running
      const requiredCommands = ['iptables', 'ip', 'iptables-save'];
      for (const cmd of requiredCommands) {
        try {
          await this.runCommand('which', [cmd]);
        } catch (error) {
          this.logger.warn(`Required command '${cmd}' not found, skipping firewall setup`);
          return;
        }
      }
      
      const result = await this.runCommand('bash', [this.firewallRulesFile]);
      
      if (result.success) {
        this.logger.info('Firewall rules applied successfully');
        this.logger.info('Firewall output:', result.stdout);
      } else {
        this.logger.error('Failed to apply firewall rules:', result.stderr);
        throw new Error(`Firewall application failed: ${result.stderr}`);
      }
    } catch (error) {
      this.logger.error('Error applying firewall rules:', error);
      throw error;
    }
  }

  /**
   * Create firewall cleanup script for common scenarios
   */
  async createFirewallCleanupScript() {
    if (this.platform === 'win32') {
      this.logger.info('Firewall cleanup script not supported on Windows platform');
      return;
    }

    if (this.platform === 'darwin') {
      this.logger.info('Firewall cleanup script not supported on macOS platform');
      return;
    }

    if (this.platform !== 'linux') {
      this.logger.info(`Firewall cleanup script not supported on platform: ${this.platform}`);
      return;
    }

    const cleanupScript = path.join(this.scriptsDir, 'firewall-cleanup.sh');
    const cleanupScriptContent = `#!/bin/bash
# Firewall Cleanup Script
# Removes VPN-related firewall rules for maintenance or troubleshooting

set -e

echo "Cleaning up VPN firewall rules..."

# Remove VPN-specific rules
iptables -D INPUT -i tun0 -j ACCEPT 2>/dev/null || true
iptables -D FORWARD -i tun0 -o tun0 -j ACCEPT 2>/dev/null || true
iptables -D FORWARD -i tun0 -j ACCEPT 2>/dev/null || true
iptables -D FORWARD -o tun0 -j ACCEPT 2>/dev/null || true

# Remove NAT rules
iptables -t nat -D POSTROUTING -s ${this.config.vpn.subnet}/24 -j MASQUERADE 2>/dev/null || true

# Remove rate limiting rules
iptables -D INPUT -p udp --dport ${this.config.vpn.port} -m limit --limit 10/min -j ACCEPT 2>/dev/null || true

echo "VPN firewall rules cleaned up"
logger "VPN-FIREWALL: Rules cleaned up"
`;

    try {
      await fs.writeFile(cleanupScript, cleanupScriptContent);
      await fs.chmod(cleanupScript, 0o755);
      
      this.logger.info('Firewall cleanup script created');
    } catch (error) {
      this.logger.error('Error creating firewall cleanup script:', error);
      throw error;
    }
  }

  /**
   * Get current firewall status
   */
  async getFirewallStatus() {
    if (this.platform === 'win32') {
      return { supported: false, message: 'Firewall status not supported on Windows' };
    }

    try {
      const result = await this.runCommand('iptables', ['-L', '-n']);
      
      return {
        supported: true,
        success: result.success,
        rules: result.stdout,
        error: result.stderr
      };
    } catch (error) {
      return {
        supported: true,
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Run command with promise wrapper
   */
  runCommand(command, args) {
    return new Promise((resolve) => {
      const process = spawn(command, args);
      let stdout = '';
      let stderr = '';

      process.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          stdout,
          stderr,
          error: code !== 0 ? stderr : null
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          error: error.message
        });
      });
    });
  }
}

module.exports = NetworkSecurityManager;